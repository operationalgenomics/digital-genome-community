//! --------------------------
//! INFORMATION
//! --------------------------
//! Title: Meristic Motor (M_M)
//! Author: Carlos Eduardo Favini
//! Date: 2025-01-02
//! Version: 1.2.0
//! Description: Motor for creative structural proposal generation.
//! Proposes new paths to increase Craft Performance without
//! modifying observed truth. Uses fractal mathematics for
//! exploration of possibility space.
//! Layer: Community
//! Dependencies: Consagrated mathematics (fractal geometry, similarity)
//! Affected Components: math/craft
//!
//! --------------------------
//! CHANGE LOG
//! --------------------------
//! 2025-01-02 - Carlos Eduardo Favini - Initial creation
//! 2025-01-02 - Carlos Eduardo Favini - Added was_clamped signaling (v0.2.0)
//! 2025-01-02 - Carlos Eduardo Favini - Added novelty_weight validation (v0.2.0)
//! --------------------------

use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

use super::CognitiveMotor;

/// Meristic Motor (M_M).
///
/// Proposes structural variations to increase Craft Performance.
/// This motor is creative but non-binding - it suggests, never decides.
///
/// # Function
/// - Explores possibility space using fractal geometry
/// - Identifies structural patterns that could improve coherence
/// - Generates proposals as non-binding appendix
///
/// # Restrictions (Constitutional)
/// - Does NOT alter observed truth
/// - Does NOT modify DNA
/// - Does NOT decide incorporation
/// - Proposals are ALWAYS non-binding
///
/// # Output
/// - Structural novelty score
/// - Coherence potential
/// - Proposals (as metadata, not executable)
/// - Continuous score [0.0, 1.0]
#[derive(Debug, Clone)]
pub struct MeristicMotor;

/// Input for the Meristic Motor.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MeristicInput {
    /// Current structural embedding of the action/DNA.
    pub current_embedding: Vec<f64>,

    /// Historical embeddings for context (may be empty).
    pub historical_embeddings: Vec<Vec<f64>>,

    /// Target domain characteristics (optional guidance).
    pub domain_characteristics: Option<BTreeMap<String, f64>>,

    /// Exploration depth (fractal iteration depth).
    /// Must be >= 1.
    pub exploration_depth: usize,

    /// Novelty weight (0.0 = pure coherence, 1.0 = pure novelty).
    /// Will be validated to [0, 1] range.
    pub novelty_weight: f64,
}

/// Validation error for Meristic input.
#[derive(Debug, Clone, PartialEq)]
pub enum MeristicValidationError {
    /// Current embedding is empty.
    EmptyCurrentEmbedding,
    /// Exploration depth must be >= 1.
    InvalidExplorationDepth,
    /// Historical embedding dimension mismatch.
    DimensionMismatch { expected: usize, got: usize, index: usize },
    /// Novelty weight is invalid (NaN or infinite).
    InvalidNoveltyWeight { value: String },
}

impl std::fmt::Display for MeristicValidationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EmptyCurrentEmbedding => {
                write!(f, "Current embedding is empty")
            }
            Self::InvalidExplorationDepth => {
                write!(f, "Exploration depth must be >= 1")
            }
            Self::DimensionMismatch { expected, got, index } => {
                write!(
                    f,
                    "Dimension mismatch at historical[{}]: expected {}, got {}",
                    index, expected, got
                )
            }
            Self::InvalidNoveltyWeight { value } => {
                write!(f, "Invalid novelty_weight: {}", value)
            }
        }
    }
}

impl std::error::Error for MeristicValidationError {}

/// A non-binding proposal generated by the Meristic motor.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MeristicProposal {
    /// Proposal identifier.
    pub id: String,

    /// Proposed structural variation (delta from current).
    pub delta_embedding: Vec<f64>,

    /// Expected improvement in coherence.
    pub expected_improvement: f64,

    /// Confidence in the proposal.
    pub confidence: f64,

    /// Description of the structural change.
    pub description: String,
}

/// Output from the Meristic Motor.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MeristicOutput {
    /// Whether the input was valid.
    pub valid: bool,

    /// Validation error if invalid.
    pub validation_error: Option<String>,

    /// Structural novelty score [0, 1].
    /// Higher = more novel relative to history.
    pub novelty_score: f64,

    /// Coherence potential score [0, 1].
    /// Higher = more aligned with domain characteristics.
    pub coherence_potential: f64,

    /// Exploration coverage [0, 1].
    /// How much of the possibility space was explored.
    pub exploration_coverage: f64,

    /// Non-binding proposals (appendix).
    pub proposals: Vec<MeristicProposal>,

    /// Final motor score: M_M = blend of novelty and coherence.
    pub score: f64,

    /// Whether the final score was clamped to [0, 1].
    pub was_clamped: bool,

    /// Original score before clamping (if was_clamped is true).
    pub unclamped_score: Option<f64>,

    /// Whether novelty_weight was adjusted from input.
    pub novelty_weight_adjusted: bool,

    /// Actual novelty_weight used (after adjustment).
    pub effective_novelty_weight: f64,
}

impl MeristicOutput {
    /// Creates an invalid output with zero score.
    fn invalid(error: MeristicValidationError) -> Self {
        Self {
            valid: false,
            validation_error: Some(error.to_string()),
            novelty_score: 0.0,
            coherence_potential: 0.0,
            exploration_coverage: 0.0,
            proposals: Vec::new(),
            score: 0.0,
            was_clamped: false,
            unclamped_score: None,
            novelty_weight_adjusted: false,
            effective_novelty_weight: 0.0,
        }
    }
}

impl MeristicMotor {
    /// Creates a new Meristic Motor.
    pub fn new() -> Self {
        Self
    }

    /// Validates input constraints.
    fn validate(input: &MeristicInput) -> Result<(), MeristicValidationError> {
        if input.current_embedding.is_empty() {
            return Err(MeristicValidationError::EmptyCurrentEmbedding);
        }

        if input.exploration_depth < 1 {
            return Err(MeristicValidationError::InvalidExplorationDepth);
        }

        // Validate novelty_weight (NaN/infinite are errors)
        if input.novelty_weight.is_nan() || input.novelty_weight.is_infinite() {
            return Err(MeristicValidationError::InvalidNoveltyWeight {
                value: format!("{}", input.novelty_weight),
            });
        }

        let dim = input.current_embedding.len();
        for (i, hist) in input.historical_embeddings.iter().enumerate() {
            if hist.len() != dim {
                return Err(MeristicValidationError::DimensionMismatch {
                    expected: dim,
                    got: hist.len(),
                    index: i,
                });
            }
        }

        Ok(())
    }

    /// Calculates L2 norm of a vector.
    fn l2_norm(v: &[f64]) -> f64 {
        v.iter().map(|x| x * x).sum::<f64>().sqrt()
    }

    /// Calculates cosine similarity between two vectors.
    fn cosine_similarity(a: &[f64], b: &[f64]) -> f64 {
        if a.len() != b.len() || a.is_empty() {
            return 0.0;
        }

        let dot: f64 = a.iter().zip(b.iter()).map(|(x, y)| x * y).sum();
        let norm_a = Self::l2_norm(a);
        let norm_b = Self::l2_norm(b);

        if norm_a == 0.0 || norm_b == 0.0 {
            return 0.0;
        }

        dot / (norm_a * norm_b)
    }

    /// Calculates novelty score based on distance from historical embeddings.
    ///
    /// Novelty = 1 - max_similarity
    fn calculate_novelty(current: &[f64], historical: &[Vec<f64>]) -> f64 {
        if historical.is_empty() {
            return 1.0; // Maximum novelty if no history
        }

        let max_similarity = historical
            .iter()
            .map(|h| Self::cosine_similarity(current, h))
            .fold(f64::NEG_INFINITY, f64::max);

        // Map similarity [-1, 1] to novelty [0, 1]
        // similarity = 1 → novelty = 0 (identical)
        // similarity = -1 → novelty = 1 (opposite)
        // similarity = 0 → novelty = 0.5 (orthogonal)
        (1.0 - max_similarity) / 2.0
    }

    /// Calculates coherence potential based on domain characteristics.
    fn calculate_coherence_potential(
        current: &[f64],
        domain: &Option<BTreeMap<String, f64>>,
    ) -> f64 {
        let domain = match domain {
            Some(d) => d,
            None => return 1.0, // No constraints = maximum potential
        };

        if domain.is_empty() {
            return 1.0;
        }

        // Extract target values from domain characteristics
        let target: Vec<f64> = domain.values().copied().collect();

        if target.len() != current.len() {
            // Dimension mismatch - use norm-based heuristic
            let current_norm = Self::l2_norm(current);
            let target_norm = Self::l2_norm(&target);

            if target_norm == 0.0 {
                return if current_norm == 0.0 { 1.0 } else { 0.5 };
            }

            // Similarity based on norm ratio
            let ratio = (current_norm / target_norm).min(target_norm / current_norm);
            return ratio;
        }

        // Same dimension - use cosine similarity
        let similarity = Self::cosine_similarity(current, &target);
        // Map to [0, 1]
        (similarity + 1.0) / 2.0
    }

    /// Explores possibility space using fractal-inspired iteration.
    ///
    /// Returns exploration coverage metric [0, 1].
    fn calculate_exploration_coverage(depth: usize, dim: usize) -> f64 {
        // Coverage grows logarithmically with depth
        // At depth 1, coverage ≈ 0.5 for typical dimensions
        // At depth 10, coverage approaches 1.0

        let base_coverage = 1.0 - (-(depth as f64) / 5.0).exp();
        let dim_factor = 1.0 / (1.0 + (dim as f64).ln());

        (base_coverage * dim_factor).clamp(0.0, 1.0)
    }

    /// Generates non-binding proposals based on exploration.
    fn generate_proposals(
        current: &[f64],
        novelty: f64,
        coherence: f64,
        depth: usize,
    ) -> Vec<MeristicProposal> {
        let mut proposals = Vec::new();
        let dim = current.len();

        // Generate proposals based on exploration depth
        // Each proposal suggests a direction of improvement
        for i in 0..depth.min(5) {
            // Create a perturbation direction
            let mut delta: Vec<f64> = vec![0.0; dim];

            // Simple perturbation strategy: emphasize different dimensions
            for (j, d) in delta.iter_mut().enumerate() {
                // Oscillating pattern based on proposal index
                let phase = ((i + j) as f64) * std::f64::consts::PI / (dim as f64);
                *d = phase.sin() * 0.1;
            }

            let expected_improvement = (novelty * 0.3 + coherence * 0.7) * (1.0 / (1.0 + i as f64));
            let confidence = 1.0 / (1.0 + i as f64);

            proposals.push(MeristicProposal {
                id: format!("proposal_{}", i),
                delta_embedding: delta,
                expected_improvement,
                confidence,
                description: format!(
                    "Structural variation {} - explore dimension emphasis",
                    i
                ),
            });
        }

        proposals
    }

    /// Calculates the final M_M score.
    ///
    /// Formula: M_M = (1 - w) × coherence + w × novelty
    /// where w is the novelty weight.
    fn calculate_score(novelty: f64, coherence: f64, coverage: f64, weight: f64) -> f64 {
        let base_score = (1.0 - weight) * coherence + weight * novelty;

        // Modulate by coverage (higher coverage = higher confidence)
        base_score * (0.5 + 0.5 * coverage)
    }
}

impl Default for MeristicMotor {
    fn default() -> Self {
        Self::new()
    }
}

impl CognitiveMotor for MeristicMotor {
    type Input = MeristicInput;
    type Output = MeristicOutput;

    /// Evaluates the structure and produces M_M score with proposals.
    fn evaluate(&self, input: &Self::Input) -> Self::Output {
        // Validate input
        if let Err(e) = Self::validate(input) {
            return MeristicOutput::invalid(e);
        }

        // Normalize novelty_weight to [0, 1] with signaling
        let raw_weight = input.novelty_weight;
        let weight_needs_adjustment = !(0.0..=1.0).contains(&raw_weight);
        let effective_weight = raw_weight.clamp(0.0, 1.0);

        // Calculate novelty score
        let novelty_score = Self::calculate_novelty(
            &input.current_embedding,
            &input.historical_embeddings,
        );

        // Calculate coherence potential
        let coherence_potential = Self::calculate_coherence_potential(
            &input.current_embedding,
            &input.domain_characteristics,
        );

        // Calculate exploration coverage
        let exploration_coverage = Self::calculate_exploration_coverage(
            input.exploration_depth,
            input.current_embedding.len(),
        );

        // Generate proposals
        let proposals = Self::generate_proposals(
            &input.current_embedding,
            novelty_score,
            coherence_potential,
            input.exploration_depth,
        );

        // Calculate raw score
        let raw_score = Self::calculate_score(
            novelty_score,
            coherence_potential,
            exploration_coverage,
            effective_weight,
        );

        // Check if clamping is needed
        let needs_clamping = raw_score < 0.0 || raw_score > 1.0 || !raw_score.is_finite();
        let final_score = if needs_clamping {
            if raw_score.is_nan() { 0.0 } else { raw_score.clamp(0.0, 1.0) }
        } else {
            raw_score
        };

        MeristicOutput {
            valid: true,
            validation_error: None,
            novelty_score,
            coherence_potential,
            exploration_coverage,
            proposals,
            score: final_score,
            was_clamped: needs_clamping,
            unclamped_score: if needs_clamping { Some(raw_score) } else { None },
            novelty_weight_adjusted: weight_needs_adjustment,
            effective_novelty_weight: effective_weight,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_validation_empty_embedding() {
        let motor = MeristicMotor::new();

        let input = MeristicInput {
            current_embedding: vec![],
            historical_embeddings: vec![],
            domain_characteristics: None,
            exploration_depth: 1,
            novelty_weight: 0.5,
        };

        let output = motor.evaluate(&input);
        assert!(!output.valid);
    }

    #[test]
    fn test_validation_invalid_depth() {
        let motor = MeristicMotor::new();

        let input = MeristicInput {
            current_embedding: vec![1.0, 2.0, 3.0],
            historical_embeddings: vec![],
            domain_characteristics: None,
            exploration_depth: 0, // Invalid
            novelty_weight: 0.5,
        };

        let output = motor.evaluate(&input);
        assert!(!output.valid);
    }

    #[test]
    fn test_validation_invalid_novelty_weight() {
        let motor = MeristicMotor::new();

        let input = MeristicInput {
            current_embedding: vec![1.0, 2.0, 3.0],
            historical_embeddings: vec![],
            domain_characteristics: None,
            exploration_depth: 1,
            novelty_weight: f64::NAN, // Invalid
        };

        let output = motor.evaluate(&input);
        assert!(!output.valid);
        assert!(output.validation_error.unwrap().contains("Invalid novelty_weight"));
    }

    #[test]
    fn test_novelty_weight_adjustment() {
        let motor = MeristicMotor::new();

        // Weight > 1.0 should be adjusted
        let input = MeristicInput {
            current_embedding: vec![1.0, 2.0, 3.0],
            historical_embeddings: vec![],
            domain_characteristics: None,
            exploration_depth: 3,
            novelty_weight: 1.5, // Out of range
        };

        let output = motor.evaluate(&input);

        assert!(output.valid);
        assert!(output.novelty_weight_adjusted);
        assert!((output.effective_novelty_weight - 1.0).abs() < 1e-10);
    }

    #[test]
    fn test_maximum_novelty_no_history() {
        let motor = MeristicMotor::new();

        let input = MeristicInput {
            current_embedding: vec![1.0, 2.0, 3.0],
            historical_embeddings: vec![], // No history
            domain_characteristics: None,
            exploration_depth: 3,
            novelty_weight: 1.0,
        };

        let output = motor.evaluate(&input);

        assert!(output.valid);
        assert!((output.novelty_score - 1.0).abs() < 1e-10);
        assert!(!output.was_clamped);
    }

    #[test]
    fn test_low_novelty_identical_history() {
        let motor = MeristicMotor::new();

        let current = vec![1.0, 2.0, 3.0];
        let input = MeristicInput {
            current_embedding: current.clone(),
            historical_embeddings: vec![current], // Identical
            domain_characteristics: None,
            exploration_depth: 3,
            novelty_weight: 1.0,
        };

        let output = motor.evaluate(&input);

        assert!(output.valid);
        // Identical = maximum similarity = minimum novelty
        assert!(output.novelty_score < 0.1);
    }

    #[test]
    fn test_coherence_with_domain() {
        let motor = MeristicMotor::new();

        let mut domain = BTreeMap::new();
        domain.insert("dim1".to_string(), 1.0);
        domain.insert("dim2".to_string(), 0.0);
        domain.insert("dim3".to_string(), 0.0);

        let input = MeristicInput {
            current_embedding: vec![1.0, 0.0, 0.0], // Aligned with domain
            historical_embeddings: vec![],
            domain_characteristics: Some(domain),
            exploration_depth: 3,
            novelty_weight: 0.0, // Pure coherence
        };

        let output = motor.evaluate(&input);

        assert!(output.valid);
        // Should have high coherence (aligned with domain)
        assert!(output.coherence_potential > 0.9);
    }

    #[test]
    fn test_proposals_generated() {
        let motor = MeristicMotor::new();

        let input = MeristicInput {
            current_embedding: vec![1.0, 2.0, 3.0],
            historical_embeddings: vec![],
            domain_characteristics: None,
            exploration_depth: 5,
            novelty_weight: 0.5,
        };

        let output = motor.evaluate(&input);

        assert!(output.valid);
        // Should generate up to min(depth, 5) = 5 proposals
        assert_eq!(output.proposals.len(), 5);
    }

    #[test]
    fn test_motor_determinism() {
        let motor = MeristicMotor::new();

        let input = MeristicInput {
            current_embedding: vec![1.0, 2.0, 3.0],
            historical_embeddings: vec![vec![0.5, 1.0, 1.5]],
            domain_characteristics: None,
            exploration_depth: 3,
            novelty_weight: 0.5,
        };

        let output1 = motor.evaluate(&input);
        let output2 = motor.evaluate(&input.clone());

        assert!((output1.score - output2.score).abs() < 1e-10);
    }

    #[test]
    fn test_score_bounds() {
        let motor = MeristicMotor::new();

        let input = MeristicInput {
            current_embedding: vec![1.0, 2.0, 3.0],
            historical_embeddings: vec![],
            domain_characteristics: None,
            exploration_depth: 10,
            novelty_weight: 0.5,
        };

        let output = motor.evaluate(&input);

        assert!(output.valid);
        assert!(output.score >= 0.0);
        assert!(output.score <= 1.0);
    }

    #[test]
    fn test_novelty_weight_effect() {
        let motor = MeristicMotor::new();

        let base_input = MeristicInput {
            current_embedding: vec![1.0, 0.0],
            historical_embeddings: vec![vec![0.0, 1.0]], // Orthogonal
            domain_characteristics: None,
            exploration_depth: 3,
            novelty_weight: 0.0,
        };

        let mut high_novelty_input = base_input.clone();
        high_novelty_input.novelty_weight = 1.0;

        let output_low = motor.evaluate(&base_input);
        let output_high = motor.evaluate(&high_novelty_input);

        // Different weights should produce different scores
        assert!((output_low.score - output_high.score).abs() > 0.01);
        assert!(!output_low.novelty_weight_adjusted);
        assert!(!output_high.novelty_weight_adjusted);
    }
}
